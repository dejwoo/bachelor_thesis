In this chapter of bachelor thesis I will provide a solution of my bachelor thesis problem.
\section{Hardware}
For the start we need device which will be capable of running operating system. There are many various platforms which provide single board computers, and after considering pros and cons I have choosen raspberry platform as most suitable becouse is is capable of running full linux operating system, have 4 USB slots which will be needed for peripheral devices and foremost there is a pleathora of hardware addons, sensors and boards which works with raspberry models, not to mention availablilty of information how to connect them, tutorials how to setup them. In time of writing this thesis I can say raspberry platform is the most popular platform for single board computers.
\subsection{Device}
After picking the right platform we need to pick model. Newest model on the market from raspberry platform in time of developing this thesis was Raspberry Pi Zero which was not suitable for the needs of this thesis becouse it lacks usb ports. It has support for On-the-go USB cables but we need device which supports atleast 2 or 3 usb ports. Which we would need to solve by buying USB hubs. The best suitable device was Raspberry Pi 2, which has 4 USB ports, 40 GPIO pins and micro SD card slot. This device covers almost all the needs of this thesis. We will need to extend it with WiFi/Bluetooth USB dongle which will enable us to create WiFi access point. In time of writing this thesis Raspberry Foundation released new device Raspberry Pi 3 which is even more suitable for us because it has buitl-in Wireless LAN. So my recommendation for the reader is to go with Raspberry Pi 3 model.
\subsection{Operating System}
The most suitable operating system for our needs is Linux based, because it is open-source. Concrete distribution of Linux based operating system will be Arch Linux. The main gain of using Arch Linux is it is extremely lightweight distribution with KISS principle in mind also it is a rolling release which means it is always always up-to-date. Port of Arch Linux distribution is Arch Linux ARM which carries forward the Arch Linux philosophy of simplicity and user-centrism, targeting and accommodating competent Linux users by giving them complete control and responsibility over the system. Instructions are provided to assist in navigating the nuances of installation on the various ARM platforms; however, the system itself will offer little assistance to the user[CITATION NEEDED].
Installing and basic configuration of Arch Linux will not be covered in this thesis, as I would repeat myself. Arch Linux has one of the best documentation online, so if you are not familiar with how to install and configure this particular Linux distribution, follow documentation from Arch Linux website.
\newpage
\section{Configuration} % (fold)
\label{sec:configuration}
In this section I will cover configuration of various applications and system properties to set up our device properly for our needs, howewer it will not be complete configuration, as peripherals connected to this device will also need some degree of setup and configuration I will cover that in their respective sections.
\subsection{Database} % (fold)
\label{sub:database}
For storing information on developing device, it needs to be capable of running database. As it is with linux there, are a lot of databases to choose from and to suit our needs we need to vary on one fact, and that is where all gathered information will be stored. Raspberry can support very large memory cards, up to 512 gigabytes, and with various read/write speeds, so one could find card which will suit oneself needs.[Citation needed] In spite of availability of different micro SD cards, everyone has limited read/write cycles after which card become unreliable. Another solution is not to store information on card at all. Typical linux database will create database file to which it stores data, in configurating we could point database to create this file in a special directory. On Linux it is called /tmp[citation needed], this direcory is allocated not on memory card but instead on RAM memory, which would save us need of large and expensive card. It comes with disadvantage, after restart or shutdown of the device, we would not be able to access stored data as RAM memory is votelatile[citation needed].
My solution for database is to use special database which sets the database in RAM memory but it is configurable to save snapshots(copies) to the micro SD card. Database is called Redis. Redis is an open source, in-memory data structure store, used as database, cache and message broker.[citation needed] Sample configuration on which database runs on our device will be provided with other configurations on GitHub repository under name ``redis.conf'' in folder ``confs''.
% subsubsection database (end)
\subsection{Wireless Access Point} % (fold)
\label{sub:wireless_access_point}
To automaticly create wireless access point when the device boots up we need several configrations and applications. Firstly the compatibility of device. To create software access point you will need nl80211 compatible wireless device[Citation needed], which support AP operating mode. Application which will be needed is hostapd, iw and dhcpcd. In the confs folder on github you can find configuration file for hostapd which needs to be copied into \verb|/etc/hostapd/|, and a systemctl rule, which needs to be copied into \verb|/lib/systemd/system/|. After that reload systemctl dameon, start and enable wifi-ap.service. If you have compliant device it will automatically create wireless Access Point which is defined in hostapd.conf.
% subsubsection wireless_access_point (end)
\subsection{Internet} % (fold)
\label{sub:internet}
As I am using Adafruit FONA 3G Cellular + GPS modem, creating connection to the Internet is possible in different ways. First is using pppd daemon which is capable upon configuration to create ppp0 device which will be used to connect to the internet. Configuration files for ppp can be found again on GitHub repository in \verb|conf/ppp| folder. Another approach is with wvdial, which congiguration can also be found in repository. At last FONA 3G is supported by QMI modem protocol. For dialing with qmi one needs to install libqmi and net-tools packages. You will need to know to which apn you need to connect from your mobile internet service provider. After that replace APN in qmi-network.conf from config folder at GitHub, copy it to \verb|/etc/|. From script folder found in thesis repository copy a helper script, and then simple \verb|qmi_setup.sh start| starts the connection to the internet. If your SIM card is PIN locked you will need to unlock it manually trough AT command or with help from \verb|mmcli| command.
% subsubsection internet (end)
% subsection configuration (end)
\newpage
\section{Peripherals} % (fold)
\label{sec:peripherals}
For providing proof of concept device which is capable of gathering information from various sources I will connect to the device numerous peripherals which will generate information. In upcoming subsections I will describe them and provide configuration instructions if necessary. I believe that connecting this peripherals is such trivia that it does not need to be explained to the reader, if however someone would not have sufficient knowledge of how to connect these to the raspberry pi I suggest to find some guide on the internet for correct connections to be made.
\subsection{Adafruit 10-DOF} % (fold)
\label{sub:adafruit_10_dof}
This inertial-measurement-unit combines 3 sensors  to give you 11 axes of data: 3 axes of accelerometer data, 3 axes gyroscopic, 3 axes magnetic (compass), barometric pressure/altitude and temperature. Since all of them use I2C, you can communicate with all of them using only two wires. Most will be pretty happy with just the plain I2C interfacing, but we also break out the data ready and interrupt pins, so advanced users can interface with if they choose.[Citation needed]. As for configuration you will need packages \verb|i2c-tools| and \verb|lm_sensors|, then get config config.txt from thesis reposirtory and copy it to /boot/config.txt, enable mondules \verb|i2c-dev, i2c-bcm2708| in \verb|/etc/modules-load.d/raspberrypi.conf|. Thats it, now with command \verb|i2cdetect -y 0| is should work. if not follow troubleshoot documentation on raspberry pi on archlinux wiki.
% subsubsection adafruit_10_dof (end)
\subsection{Adafruit FONA 3G Cellular + GPS} % (fold)
\label{sub:adafruit_fona_3g_cellular_gps_}
The FONA 3G has better coverage, GSM backwards-compatibility and even sports a built-in GPS module for geolocation & asset tracking. This all-in-one cellular phone module with that lets you add location-tracking, voice, text, SMS and data to your project in a single breakout.[citation needed] As for configuration there are multiple ways how to connect to the internet, send SMS and make voice calls, all of them boils down to using right AT commands through serial console which is automatically created by the kernel.After connecting modem through usb to the raspberry, kernel will create 4 serial ports(debug,nmea,serial,modem). After starting gps chip with correct command \verb|at+cgps=1| at serial port nmea will start to push gps data on nmea port at 115200 baud rate.
% subsubsection adafruit_fona_3g_cellular_gps_ (end)
% subsection peripherals (end)
\newpage
\section{Software} % (fold)
\label{sec:software}
\subsection{Problem abstraction} % (fold)
\label{sub:problem_abstraction}
To solve given task, lets firts look at data gathering and what can be done to optimize proccess of collecting infromation from often vary different sources. For correct conclusion to be made, we need to abstract the meaning of car connection as merely only as one of infromation sources. To solve how to easily interconnect different input sources(information producing) to even more different output sinks(information sending), lets develop a framework. A data applicaton module which will provide easy connecting of different sources with data producing modules to any data accepting modules. So to begin lets define some construction blocks of this framework so we can easily build a suitable application.
% subsection problem_abstraction (end)
\subsection{Data Logger framework} % (fold)
This framework will be a standalone module which will be incorporated in the final application. Main goal of this framework is to provide easy way how to setup communication between various inputs(sensoric data, IoT devices, cars,etc) and outputs(database,application, server, cloud,etc). Framework is structured by main app, modules and routes. Data Logger is configurable trough internal function and by file which serves for storing configurations of each model and routes. This is the first version of the framework and will probably undergo some more development.
\subsubsection{Module}
\label{ssub:module}
Module is basic structure for every item. It is a encapsulating class for every information creating or sending application/module. By this framework is able to objectify every application be it different, and extract data from generating one or send data to to accepting one. By this single feature we will be albe to get data from OBD port of the car system the same way as from accelometer present at Adafruit 10 DOF sensoric board. This is achieved by writing specific modules to parse/get data from the source, which are then run under Data Logger. Every module can be generating data, or accepting data and acting upon it. For modul to be generating or accepting one, module must be implemented by the same interface so it can be easily handled by Data Logger, otherwise this would not be much of a framework if for every module there would need to be specific functions to run to obtain or accept data. Configurating modules are easy as from framework we can pass settings for every module separatly, either from application or much easier from a file. This configuration file has a specific block of configruation settings for every module present in current implementation of Data Logger.[Picture needed]
\subsubsection{Route} % (fold)
\label{ssub:route}
Route is another basic structure how to define a dataflow from or to every module. Routes are defined with simple principle in mind, you define source and then every possible sink to which data have to be sent. By this configuration Data Logger will begin to accessing modules based on which side of the equation they are. If the module is generating data, framework will use specific general interface to gather data provided by the module and then distribute it to every sink defined by the route again by using general interface to sending data to module. With this principle one can define a very detailed data flow and by which assamble a data handling application in no time. If we would scale this framework to enourmous proportions, say we would have 10 sensors producing same data but they would need different modules to be handled, it would become soon tedious to write routes based only on id matching of modules. So for every module theres a specific setting to be set, a type, by which we can more easily define routes, e.g. \verb|accelerometer -> database| and from now on, every data produced by module which has type set to acceloremeter will be routed to every module which as type of database, may there be big number of them.[Picture needed]
% subsubsection route (end)
\label{sub:data_logger_framework}
% subsection data_logger_framework (end)
\subsection{Data Logger modules}

In this section of bachelor thesis I will desciribe modules which I developed in order to complete assignment.
\subsubsection{Blank module} % (fold)
\label{ssub:blank_module}
% subsubsection blank_module (end)

\subsubsection{Time module} % (fold)
\label{ssub:time_module}
This is simple `dumb' module which will be used to beta test others modules. Advantage of having this simiplistic module is it is not dependent on any hardware. Interval defined by sample rate will provide current time as data.
% subsubsection time_module (end)
\subsubsection{Accelerometer module} % (fold)
This module will be dependent on Adafruit 10 DOF sensor board and will utilize onboard LSM303 accelerometer sensor, communicating over I2C protocol. Module will emit proper acceleration in 3 axis, maximum acceleration +- 16g in each direction, sample rate will be configurable. LSM303 accelerometer sensor supports various settings as which axis acceleration is registered, how fast are these values checked, this constants for these settings are implemented, but I do not see the benefit of selecting only one axis or sampling at lower rate, so defaults are every axis is registered, and sampled as fast as it can be for accident checking module.
% subsubsection accelerometer_module (end)
\label{ssub:accelerometer_module}
\subsubsection{GPS module} % (fold)
\label{ssub:gps_module}
GPS module as name suggests will parse nmea sentences from FONA 3g modem which has built-in GPS chip. AS for this module there is not much to be configured, because modem emits nmea sentences at 115200 rate, which to my best knowledge is not configurable, only thing found which could be configured is to switch output port for nmea sentences from nmea to serial, but then sending SMS and calling would not be possible, so it is not a feasible setting.
% subsubsection gps_module (end)
\subsubsection{Accident module} % (fold)
\label{ssub:accident_module}
This module will be both accepting input data and creating new information for other modules. New cars electronic crash sensors are accelometers. They are used to determine exactly when the airbag should be deployed to prevent injury to a driver or passenger.   When an impact occurs, it results in vehicle deceleration, which is sensed by the accelerometer. This change is monitored by electronic control unit, which sends a signal to trigger the airbag. Not to rely on car accelerometer sensors the application will be polling LSM303 accelerometer sensor attached to the device. Problem with car accelerometer sensors is missing common interface to communicate with airbag/ECU system. If it is even possible then every car manafacturer has proprietary system in place, which would result in buying different specifications for every make, maybe even model. As for giving the gathered information value, I am not suitable for the task for simple reason, I am application comuter science undergrad and I can create, gather, store, act upon, etc based on information but to assign which value from accelerometer is right to register accident I have no knowledge, it is probably better task for someone from physics field. To create this module smart, in settings can be found treshold value which says that if accelerometer module registers acceleration over treshold accident module will be trigered and will compose a sos message to be sent to emergency dispatch centre. This message will be composed of latest GPS positon, maximal g-forces registred and medical information about driver. Medical information about driver, or in other words custom message is also configurable through settings.
% subsubsection accident_module (end)
\subsubsection{SMS module} % (fold)
\label{ssub:sms_module}
% subsubsection sms_module (end)
\subsubsection{OBD-II module} % (fold)
\label{ssub:obd_ii_module}
% subsubsection obd_ii_module (end)
\subsubsection{IFTTT module} % (fold)
\label{ssub:ifttt_module}
% subsubsection ifttt_module (end)
\subsubsection{Redis module} % (fold)
\label{ssub:redis_module}
% subsubsection redis_module (end)
\subsubsection{RPM module} % (fold)
\label{ssub:rpm_module}
% subsubsection rpm_module (end)
\subsubsection{RabbitMQ module} % (fold)
\label{ssub:rabbitmq_module}
% subsubsection rabbitmq_module (end)
\subsubsection{Console module} % (fold)
\label{ssub:console_module}
% subsubsection console_module (end)
\subsubsection{Bulk module} % (fold)
\label{ssub:bulk_module}
% subsubsection bulk_module (end)

% subsection data_logger_modules (end)







% subsection software (end)