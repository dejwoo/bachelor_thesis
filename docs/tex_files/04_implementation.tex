In this chapter of bachelor thesis I will provide a technical implementation details regarding my solution.
\section{Overview} % (fold)
\label{sec:overview}
For completing this bachelor assignment I have choosen to implement it in Javascript programming language, which provides various benefits for its implementation.
\begin{itemize}
\item Over 70\% of the code is implemented in JavaScript, rest is HTML and CSS.
\item Application is operating system independent
\item For backend solution I used Node.js, which is also implemented in JavaScript. So there is no need to know another programming language by the users
\item The npm packgage registry holds over 250,000 reusable packages of reusable code.
\end{itemize}
As you can see there is a lot of support surrounding Node.js enviroment which enabled me to build better and faster application.

% section overview (end)
\section{Data Logger} % (fold)
\label{sec:Data Logger}
Data Logger is a standalone module. When Data Logger is required whole module is instantiated. For correct configuration it is needed to call configurate function with JavaScript Object as a argument which is passed by reading JSON configuration file from main application.
\subsection{Modules} % (fold)
\label{sub:modules}
% subsection module (end)
To process the file, modules have to be created by instantiating them with module options, which are then storted in internal key value object where keys are unique ids supplied by the user. As this framework is primarily used for fellow computer scientists and power users, Data Logger does not implement any failsafe for not overwriting modules with same ID. This happend to be a mistake to forego this failsafe, and will be reported as one of many things to be improved in continued work after this thesis.
\subsection{Routes} % (fold)
\label{sub:routes}
After modules are instantiated it is time for creating data flows defined by routes. To standardize data exchange format every message must be Javascript Object. Every message traveling between modules must be composed of these 2 key mapped values, firstly its header where the mandatory key is id, whichs value is reffering to the module in which message originated. Other properties of message header are optional and can be configured with main config file. Second mandatory key maped value is body, in which is stored actual data payload created by original module.[TODO TODO TODOTODOTODOOOO TODODO TABLE]

To better understand what interfaces must be implemented by the modules so they could create data or accept data I provide them in specification of interfaces below.
\subsubsection{Interface of data creating module} % (fold)
\label{ssub:interface_of_data_creating_module}
For data created by the module to by properly handled by Data Logger module object must be a instance of the EventEmmiter class which exposes an eventEmitter.on() functions that allows for registering event listeners to that particular object. When object emits a specificly named event every function attached by on() function are called synchronously. So for data to be picked up be the Data Logger module must emit `data' event witch argument is created data by the module. Nothing more is mandatory to by implemented.
% subsubsection interface_of_data_creating_module (end)

\subsubsection{Interface of data accepting module} % (fold)
\label{ssub:interface_of_data_accepting_module}
Module which will be accepting data must be an instance of Stream Writable abstract class designed to be extended with an underlying implementation of the .\_write method. This method must be implemented to accept data passing to the underlying resource in case of this thesis -- module. Method \_write  has 3 arguments, (chunk, encoding, callback). Data intended for the module is in chunk variable.

% subsubsection interface_of_data_accepting_module (end)

% subsection routes (end)

% section section_name (end)